# 软件基础试题

[题目](./ProgrammingQuestion.pdf)

---

一、在C语言中：

1. 整型数`i++`和`++i`的区别

   > - 作为右值时，`i++`先赋值，再自增；`++i`先自增，再赋值。
   > - `i++`的原理是先用临时对象保存原来的对象，然后对原对象自增，再返回临时对象。不能作为左值。
   > - `++i`的原理是直接对原对象进行自增，然后返回原对象的引用，可以作为左值。

2. `(*p)++`和`++(*p)`的区别

   > - `(*p)++`先取指针`p`指向的值，再返回该值，最后对值自增。
   > - `++(*p)`先取指针`p`指向的值，再对值自增，最后返回自增后的值。

3. `*p++`和`*++p`的区别

   >前缀递增递减和`*`优先级相同。后缀递增递减比前缀优先级高。
   >```c
   >int arr[5] = { 1,3,5,7,9 };
   >int *p = arr;
   >```
   >
   >- `*p++`中先执行的是`p++`，而`p++`首先返回`p`，相当于`*p`，得到`p`的值并返回，整个语句执行完毕后再对指针`p`自增，指向下一个对象。即`*p++`整体返回当前对象的值并将指针指向下一个对象。上面的例子中如果运行`*p++`则会返回`1`，指针`p`指向`arr[1]`。
   >- `*++p`中，先执行的是`*`，`*`要取后面的`++p`的值，而`++p`显然会先将指针指向下一个对象再返回，此时`*`取到的值就是下一个对象的值。即`*++p`整体返回下一个对象的值并且指针也指向下一个对象。上面的例子中如果运行`*++p`则会返回`3`，指针`p`指向`arr[1]`。

4. 用三种方法实现死循环，写出函数框架

   > - 使用while语句
   >
   >   ```c
   >   void loop(){
   >       while(1){
   >           //some code...
   >       }
   >   }
   >   ```
   >
   > - 使用for语句
   >
   >   ```c
   >   void loop(){
   >       for( ; ; ){
   >           //some code...
   >       }
   >   }
   >   ```
   >
   > - 使用goto语句
   >
   >   ```c
   >   void loop(){
   >       LOOP:
   >       //some code...
   >       goto LOOP;
   >   }
   >   ```

5. 简述 `static`，`extern`，`const`，`volatile` 关键字的作用及用法

   > - `static`
   >
   >   1. 当同时编译多个文件时，所有未加`static`前缀的全局变量和函数都具有全局可见性，即可以被其他源文件访问到。使用`static`关键字之后，该变量就不能被其它源文件访问了，利用这一特性可以防止命名冲突。用法：
   >
   >      ```c
   >      /*****main.c中****/
   >      static char a = 'a';
   >
   >      /*****a.c中*****/
   >      //上面的变量a因为加了static，所以这里就不能访问了
   >      extern char a;
   >      ```
   >
   >   2. 保持变量内容的持久。比如在局部变量之前加上`static`，就能使其持续存在而不被清除。另外，即使该代码块从未运行，但该变量在程序启动时就已经被创建好了。用法：
   >
   >      ```c
   >      int fun(){
   >          static int count = 10;
   >      }
   >      int main(){
   >          //即使fun()没运行过，也可以访问count
   >      	printf("%d", count);	//10
   >      	return 0;
   >      }
   >      ```
   >
   >   3. 将变量默认初始化为0。`static`修饰的变量和全局变量一样，都存储在静态存储区，该区域初始值均为0。
   >
   > - `extern`
   >
   >   关键字`extern`可以在一个文件中声明暂未定义的变量，引用另一个文件中定义的变量或者函数。
   >
   >   1. 声明同一源文件中暂未定义的变量，作用类似于函数声明。
   >
   >      ```c
   >      #include <stdio.h>
   >
   >      int main(){
   >          extern int num;
   >          printf("%d", num);
   >          return 0;
   >      }
   >
   >      int num = 1;
   >      ```
   >
   >   2. 引用另一个文件中定义的变量或函数。
   >
   >      ```c
   >      /*****main.c*****/
   >      #include <stdio.h>
   >      int main(){
   >          extern int num;
   >          extern void fun();
   >          printf("%d", num);
   >          fun();
   >          return 0;
   >      }
   >                  
   >      /*****a.c*****/
   >      int num = 1;
   >      void fun(){
   >          //some code...
   >      }
   >      ```
   >
   > - `const`
   >
   >   `const`用于定义常量，即不能被修改的量。与预编译指令`define`不同的是，`define`只能机械地替换源代码中的关键字，有可能出现错误，而`const`定义的常量其实具有变量的属性，占据内存空间，更加灵活。
   >
   >   用`const`定义的常量指针是指不能通过这个指针改变指向的内容。但是指向的内容可以通过其他方法修改，而这个常量指针指向的地址也可以修改为其他地址。
   >
   >   ```c
   >   //两种声明方法都可以
   >   const int *num;
   >   int const *num;
   >   ```
   >
   >   用`const`定义的指针常量是指这个指针本身是个常量，不能修改它指向的地址。
   >
   >   ```c
   >   int *const num;
   >   ```
   >
   > - `volatile`
   >
   >   `volatile`修饰的变量一般是经常发生变化的，比如一些受操作系统、硬件影响的变量，又或是多线程共用的变量。
   >
   >   通常在代码编译阶段，编译器会对代码进行优化以加快代码执行速度。比如，编译器发现程序读取某一变量，如果该变量在当前代码中没有被修改，编译器会把这个变量暂存在寄存器中（寄存器的读取速度非常快），当下一次读取这个变量时，程序会直接读取寄存器中缓存的值。如果在此阶段中，变量因为其他原因改变了（最常见的还是多线程的时候被另一线程修改了），那么当前的代码读取的还是之前缓存的值，就会出现问题。
   >
   >   使用`volatile`关键字修饰变量，编译器就不再对此变量进行优化，每次读取都会重新访问内存中的地址以获取最新的值，由此可以避免一些错误。
   >
   >   同样的，`volatile`关键字也可以声明指针，表示此指针指向的地址是易变的。



二、使用C语言或 Python、 JAVA、 C++制作一个成员管理系统，系统要求实现：
1. 输入功能：录入成员信息（包括姓名，学号，性别，学院，年级，专业）。

2. 显示功能：完成成员记录的显示。

3. 查找功能：完成按照姓名，学号查找相应记录，并显示。

   > 使用Python完成了`Students Data Manage System`，源码位于[source](./source/)文件夹。
   >
   > - `main.py`是主程序。
   > - `Database.py`是封装了MySQL操作的数据库模块。
   >
   > 使用MySQL数据库保存成员信息，故运行之前需要配置MySQL数据库。
   >
   > 完成了增删改查等操作。